mainmodule SuperResolution {
include "pup_stl.h";

readonly CProxy_Main mainProxy;
readonly CProxy_DBNode dbProxy;
readonly int nodeCount;

message CandidateList;

nodegroup DBNode {
  entry DBNode(void);
  entry void FillDB(const string& sTrainingSetDirPath);
  // read all db, but rstricted search space

  entry void SearchDB(Patch patch,CkCallback callBack_);
};

mainchare Main {
  entry Main(CkArgMsg *m);
  entry [reductiontarget] void CheckConverged(CkReductionMsg *msg);

  entry [reductiontarget] void DB_Populated();
  /*
  Recv final patch and create the hiRes image
  */
  entry void RecvFinalPatch(CkReductionMsg *msg);

  entry void WaitForFinalPatches() {
    forall [block] (1:num_images, 1) {
      when RecvFinalPatch(CkReductionMsg *msg) serial {
        patch_t *p = (patch_t*) msg->getData();
        int num_elements = msg->getSize() / sizeof(patch_t);
        int idx = msg->getUserFlag();
        CkPrintf("RecvFinalPatch from idx %d\n", idx);

        string sFilePath = sOutputImageFolderPath + "/" + std::to_string(idx) + ".txt";
        ImageDB *DB = dbProxy.ckLocalBranch()->GetImageDB();
        WriteFinalPatches(sFilePath, DB, p, num_elements, arrayXDims[idx], arrayYDims[idx]);
      }
    }
    serial { CkExit(); }
  };
};

array [2D] PatchArray {
  entry PatchArray(vector<Patch>, int idx, int arrayXDim, int arrayYDim); //call setup 

  entry void RecvCandidatesFromNeighbors(int from, vector<PatchID> patches); 
  entry void RecvMessageFromNeighbor(int itr,int from,vector<double> msg);
  entry void GetFinalPatch(); // calls cb RecvFinalPatch on mainProxy
  entry [reductiontarget] void RecvCandidatesFromRemoteDB(CandidateList* patches); 
  entry void Setup() {
    serial "local search and remote requests" {
      SetupPatch(); //finds the candidate patches and send request for remote search    
      CkPrintf("[%d,%d]Waiting to receive remote search results\n",thisIndex.x,thisIndex.y);
    }
    for(recv_count = 0; recv_count < nodeCount -1;++recv_count)
    {
        when RecvCandidatesFromRemoteDB(CandidateList* patches)
        serial "process candidates from remote DB" {
           ProcessCandidatesFromRemoteDB(patches);
        }
    }
    
    serial "consolidate candidates and send to neighbors" {     
        CkPrintf("[%d,%d]Done receiving remote search results\n",thisIndex.x,thisIndex.y);
        ConsolidateCandidates();
        SendPatchesToNeighbors();
    }

    if (j_index > 0) { //recv from WEST
      when RecvCandidatesFromNeighbors(int from, std::vector<PatchID> indices)
      serial "Process Patch from WEST" {
        ProcessCandidates(from, indices);
      }
    }

    if (j_index < arrayYDim-1) { //recv from EAST
      when RecvCandidatesFromNeighbors(int from, std::vector<PatchID> indices)
      serial "Process Patch from EAST" {
        ProcessCandidates(from, indices);
      }
    }

    if (i_index > 0) {  //recv from north. 
        when RecvCandidatesFromNeighbors(int from, std::vector<PatchID> indices)
      serial "Process Patch from NORTH" {
        ProcessCandidates(from, indices);
      }
    }

    if (i_index < arrayXDim-1) { //recv from south. 
      when RecvCandidatesFromNeighbors(int from, std::vector<PatchID> indices)
      serial "Process Patch from SOUTH" {
        ProcessCandidates(from, indices);
      }
    }

    serial "init msgs" {
      InitMsg();
    }
    serial "call run" {
      Run();
    }
  };

  entry void Run()
  {
    for (iter = 0; iter < CONV_PERIOD; ++iter)
    {
      serial "Compute message" {
        ComputeMessages();
        SendMessagesToNeighbors();
      }

      if (j_index > 0) {
        when RecvMessageFromNeighbor[iter](int itr, int from, vector<double> msg) serial "Process message west" {
           ProcessMsgFromNeighbor(from, msg);
        }
      }

      if (j_index < arrayYDim-1) {
        when RecvMessageFromNeighbor[iter](int itr, int from, vector<double> msg) serial "Process message east" {
          ProcessMsgFromNeighbor(from, msg);
        }
      }

      if (i_index > 0) {
        when RecvMessageFromNeighbor[iter](int itr, int from, vector<double> msg) serial "Process message north" {
          ProcessMsgFromNeighbor(from, msg);
        }
      }

      if (i_index < arrayXDim-1) {
        when RecvMessageFromNeighbor[iter](int itr, int from, vector<double> msg) serial "Process message south" {
          ProcessMsgFromNeighbor(from, msg);
        }
      }
    }

    serial "convergence test" 
    {
       ConvergenceTest(); 
    }
  }; 
 };

  initnode void registerCustomReduction(); 
};
